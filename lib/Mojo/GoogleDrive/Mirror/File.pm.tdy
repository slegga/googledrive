package Mojo::GoogleDrive::Mirror::File;
use Mojo::Base -base, -signatures;
use Mojo::UserAgent;
use Mojo::File 'path';
use Mojo::URL;
use File::MMagic;
use Mojo::JSON qw /encode_json decode_json/;

our %metadata_all = ();

has 'pathfile';
has 'remote_root';
has 'local_root';      # => path('/');
has 'api_file_url';    # => "https://www.googleapis.com/drive/v3/files";
has 'api_upload_url';  # => "https://www.googleapis.com/upload/drive/v3/files";
has 'oauth';           #     => OAuth::Cmdline::GoogleDrive->new();
has 'sync_mode';       # => 'both-cloud'; # both ways clound wins if in conflict
has 'metadata' => sub { {} };
has ua         => sub { Mojo::UserAgent->new };

sub lfile {
    my $self = shift;
    die "Missing local_root" if !$self->local_root;
    return $self->local_root->child( $self->pathfile );
}

sub rfile {
    my $self = shift;
    $self->remote_root('/') if !$self->remote_root;
    return $self->remote_root->child( $self->pathfile );
}

sub get_metadata($self) {
    my $metadata;
    $metadata = $self->metadata if ( $self->metadata );
    if ( !ref $metadata || !keys %$metadata ) {
        $metadata = $metadata_all{ $self->pathfile };
    }
    if ( !ref $metadata || !keys %$metadata ) {
        $metadata = { name => $self->lfile->basename };
        $metadata->{parents}->[0] = @{ $self->path_resolve() }[-2];
        $metadata_all{ $self->lfile->to_string } = $metadata;
    }
    return $metadata;
}

sub upload {

   #POST https://www.googleapis.com/upload/drive/v3/files
   # https://mojolicious.io/blog/2017/12/11/day-11-useragent-content-generators/
    my $self        = shift;
    my $main_header = { $self->{oauth}->authorization_headers() };
    $main_header->{'Content-Type'} = 'multipart/related';
    my $local_file_content = $self->lfile->slurp;
    my $byte_size;
    {
        use bytes;
        $byte_size = length($local_file_content);
    }
    my $metadata = $self->get_metadata;
    my $metapart = {
        'Content-Type'   => 'application/json; charset=UTF-8',
        'Content-Length' => $byte_size,
        content          => encode_json($metadata),
    };
    my $urlstring =
      $self->api_upload_url->query( uploadType => 'multipart' )->to_string;
    say $urlstring;
    my $tx = $self->ua->post(
        $urlstring,
        $main_header,
        multipart => [
            $metapart,
            {
                'Content-Type' => $self->file_mime_type,
                content        => $local_file_content,
            }
        ]
    );
    my $meta = decode_json( $tx->res->body );
    my $md   = $self->metadata;
    $md->{$_} = $meta->{$_} for ( keys %$meta );
    $self->metadata($md);
    $metadata_all{ $self->pathfile } = $md;
    return $self;
}

###########################################
sub file_mime_type {
###########################################
    my ( $self, $file ) = @_;

    # There don't seem to be great implementations of mimetype
    # detection on CPAN, so just use this one for now.

    if ( !$self->{magic} ) {
        $self->{magic} = File::MMagic->new();
    }

    return $self->{magic}->checktype_filename($file);
}

###########################################
sub path_resolve($self) {
###########################################
    my @parts = grep { $_ ne '' } path( $self->pathfile )->to_array;

    my @ids       = qw(root);
    my $folder_id = my $parent = "root";
    say "Parent: $parent" if $ENV{MOJO_DEBUG};

    my $parent_id;
    my $tmppath = path('/');
  PART: for my $part (@parts) {
        $tmppath = $tmppath->child($part);
        say "Looking up part $part (folder_id=$folder_id)" if $ENV{MOJO_DEBUG};
        my $dir;
        if ( exists $metadata_all{$tmppath} ) {
            $dir = Mojo::GoogleDrive::Mirror::File->from_metadata(
                $metadata_all{$tmppath} );
        }

        if ( !$dir ) {
            $dir = Mojo::GoogleDrive::Mirror::File->from_metadata(
                { id => $parent_id, name => $part } );
        }

        my $children = $dir->list;

        return unless defined $children;

        for my $child (@$children) {
            say "Found child ", $child->title() if $ENV{MOJO_DEBUG};
            if ( $child->metadata->{title} eq $part ) {
                $parent_id = $child->metadata->{id};
                unshift @ids, $parent_id if $ENV{MOJO_DEBUG};

                #say  "Parent: $parent_id";
                next PART;
            }
        }

        my $msg = "Child $part not found";
        $self->error($msg);
        ERROR $msg;
        return;
    }

    if ( @ids == 1 ) {

        # parent of root is root
        return ( @ids, @ids );
    }

    return (@ids);
}

sub from_metadata ( $self, $metadata ) {
    my $return = Mojo::GoogleDrive::Mirror::File->new( metadata => $metadata );
}

sub list($self) {
    my ($self) = @_;

    my $folder_id;
    $folder_id = $metadata_all{ $self->pathfile }->{parents}->[0]
      if exists $metadata_all{ $self->pathfile };
    if ( !$folder_id ) {

    }

    my $url = Mojo::URL->new( $self->{api_file_url} );
    my $opts->{'q'} = "'$folder_id' in parents";

    #    if ( my $title = $search_opts->{title} ) {
    #        $title =~ s|\'|\\\'|g;
    #        $opts->{q} .= " AND title = '$title'";
    #    }

    my @children = ();

    while (1) {
        $url = $url->query($opts);

        my $json = $self->ua->get($url)->res->body;
        my $data = from_json($json);

        return unless defined $data;

        my $next_item = $self->item_iterator($data);

        while ( my $item = $next_item->() ) {
            push @children, $self->data_factory($item);
        }

        if ( $search_opts->{page} and $data->{nextPageToken} ) {
            $opts->{pageToken} = $data->{nextPageToken};
        }
        else {
            last;
        }
    }

    return \@children;
}

1;
